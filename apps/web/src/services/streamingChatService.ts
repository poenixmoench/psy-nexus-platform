export interface StreamMessage { type: 'chat_token' | 'code_block' | 'metadata' | 'done' | 'error'; content?: string; code?: { language: string; content: string; filename: string }; agentRole?: string; filePath?: string; timestamp?: string; }
export interface StreamCallbacks { onToken: (token: string) => void; onCodeBlock: (code: StreamMessage['code'], filePath: string) => void; onMetadata: (metadata: any) => void; onDone: () => void; onError: (error: string) => void; }
export const streamChat = async (agent: string, message: string, callbacks: StreamCallbacks): Promise<void> => { const apiUrl = `${import.meta.env.VITE_API_URL || 'http://localhost:3001'}/api/stream/chat`; try { const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ agent, message }) }); if (!response.ok) throw new Error(`API error: ${response.status}`); const reader = response.body!.getReader(); const decoder = new TextDecoder(); let buffer = ''; let done = false; while (!done) { const { value, done: streamDone } = await reader.read(); done = streamDone; if (value) { buffer += decoder.decode(value, { stream: true }); const lines = buffer.split('\n\n'); buffer = lines.pop() || ''; for (const line of lines) { if (!line.startsWith('data: ')) continue; try { const msg: StreamMessage = JSON.parse(line.replace('data: ', '')); switch (msg.type) { case 'chat_token': if (msg.content) callbacks.onToken(msg.content); break; case 'code_block': if (msg.code) callbacks.onCodeBlock(msg.code, msg.filePath || ''); break; case 'metadata': callbacks.onMetadata(msg); break; case 'done': callbacks.onDone(); break; case 'error': callbacks.onError(msg.content || 'Error'); break; } } catch (e) {} } } } } catch (error) { callbacks.onError(error instanceof Error ? error.message : 'Error'); } };
