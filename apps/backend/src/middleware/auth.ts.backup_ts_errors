import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

// Keine lokale Definition von UserPayload oder CustomRequest hier!
// Diese sollten in express.d.ts global definiert sein.
// import { UserPayload } from '../types/express'; // Falls du es separat importieren willst, ist das okay.

// Middleware zur JWT-Authentifizierung und -Autorisierung
export function authenticateToken(req: Request, res: Response, next: NextFunction) { // Benutze Request direkt, die Erweiterung erfolgt global
  const authHeader = req.headers['authorization'];
  // Format: Bearer <token>
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access denied. No token provided.' });
  }

  const secret = process.env.JWT_SECRET;
  if (!secret) {
    console.error('JWT_SECRET is not defined in environment variables!');
    return res.status(500).json({ error: 'Server configuration error: Missing JWT secret.' });
  }

  jwt.verify(token, secret, (err, decodedUser) => {
    if (err) {
      // 403 Forbidden: Token ist ungültig oder abgelaufen
      console.error('JWT Verification Error:', err);
      return res.status(403).json({ error: 'Invalid or expired token.' });
    }

    // Das 'decodedUser' enthält den Payload des Tokens (z.B. { id: ... })
    // Speichere es im Request-Objekt ab, damit nachfolgende Handler darauf zugreifen können
    // Stellen Sie sicher, dass Ihre globale Typdefinition (z.B. express.d.ts) dies unterstützt
    // req.user ist vom Typ UserPayload (aus express.d.ts), also casten wir decodedUser entsprechend
    req.user = decodedUser as UserPayload; // <-- Dieser Typ 'UserPayload' wird aus der globalen Deklaration erwartet
    next(); // Gehe zur nächsten Middleware/Route
  });
}
